Recoverable Mutual Exclusion with Constant Amortized RMR Complexity from Standard Primitives,"Motivated by advances in non-volatile memory technology, recent research in mutual exclusion has focused on algorithms for a shared memory model, in which failed processes can recover from crashes. Golab and Ramaraju [9] defined the recoverable mutual exclusion problem, where a process may crash during a mutual exclusion protocol. Upon crashing a process's local memory is erased, and it starts a recovery procedure. The contents of the shared memory survives process failures."
An O(log3/2 n) Parallel Time Population Protocol for Majority with O(log n) States,"In population protocols, the underlying distributed network consists of n nodes (or agents), denoted by V, and a scheduler that continuously selects uniformly random pairs of nodes to interact. When two nodes interact, their states are updated by applying a state transition function that depends only on the states of the two nodes prior to the interaction. The efficiency of a population protocol is measured in terms of both time (which is the number of interactions until the nodes collectively have a valid output) and the number of possible states of nodes used by the protocol. By convention, we consider the parallel time cost, which is the time divided by n."
Fine-grained Analysis on Fast Implementations of Distributed Multi-writer Atomic Registers,"Distributed multi-writer atomic registers are at the heart of a large number of distributed algorithms. While enjoying the benefits of atomicity, researchers further explore fast implementations of atomic reigsters which are optimal in terms of data access latency. Though it is proved that multi-writer atomic register implementations are impossible when both read and write are required to be fast, it is still open whether implementations are impossible when only write or read is required to be fast. This work proves the impossibility of fast write implementations based on a series of chain arguments among indistiguishable executions. We also show the necessary and sufficient condition for fast read implementations by extending the results in the single-writer case. This work concludes a series of studies on fast implementations of distributed atomic registers."
Self-Stabilizing Leader Election in Regular Graphs,"Population protocols [3] are used as a distributed model that captures the behavior of passively mobile agents. Leader election is one of the most well-studied problems in this model. In this paper, we focus on the self-stabilizing leader election (SSLE) problem proposed by Angluin et al. [5]. Previously, it is known that SSLE can be performed on arbitrary rings and tori with a constant number of states [11], but SSLE on complete graphs requires Ω(n) states [9]."
Brief Announcement: Optimal Time and Space Leader Election in Population Protocols,"Population protocols are a model of distributed computing, where n agents with limited computational power and memory perform randomly scheduled pairwise interactions. Recently, a significant amount of work has been devoted to the study of the time and space complexity of leader election in this model. It is known that Ω (log log n) states per agent are needed to elect a leader in fewer than [EQUATION] expected interactions (Alistarh et al.; SODA'17) and that Ω (n log n) expected interactions are required regardless of the number of states (Sudo and Masuzawa; 2020). On the positive side, Gasieniec and Stachowiak (SODA'18) gave the first protocol that uses an optimal Θ(log log n) number or states and elects a leader in O(n log2n) expected interactions. This running time was subsequently improved to O(n log n log log n) (Gasieniec et al.; SPAA'19). We provide the first leader election population protocol that is both time and space optimal, electing a leader in O(n log n) expected interactions and using Θ(log log n) states per agent. A novel component is a simple protocol that efficiently selects a small set of agents of polylog n size, given O(n∈) initially selected agents. Unlike existing approaches, which monotonically shrink this initially selected set, we first grow it in a controlled way to a specific size before shrinking it again."
Brief Announcement: Intermediate Value Linearizability: A Quantitative Correctness Criterion,"A common correctness criterion for concurrent objects is linearizability. Intuitively, under linearizability, when a read overlaps an update, it must return either the object's value before the update or the value after it. Consider, for example, a batched counter supporting ""batched"" increments, and a single operation that bumps its value from 7 to 10. A read overlapping this update is allowed to return either 7 or 10. In this paper, we propose Intermediate Value Linearizability (IVL), a new correctness criterion that relaxes linearizability to allow returning intermediate values, for instance, 8 in the example above. IVL is applicable to objects whose return values are from a totally ordered set. Roughly speaking, it allows reads to return any value that is bounded between two return values that are legal under linearizability. We show that this added degree of freedom inherently allows for cheaper implementations than linearizability. In particular, we show a lower bound of Ω(n) on the step complexity of the update operation of a wait-free linearizable batched counter, and give a wait-free IVL implementation of the same object with an O(1) step complexity for update."
Brief Announcement: On Implementing Software Transactional Memory in the C++ Memory Model,"High-performance software transactional memory (STM) implementations rely on nuanced use of synchronization variables to coordinate speculative accesses to program data. We discuss some consequences of the C++ memory model on STM, identify an easy-to-fix implementation error, and describe an unavoidable formal race condition that occurs in an important class of STM algorithms."
Brief Announcement: Self-stabilizing Systems in Spite of High Dynamics,"We initiate research on self-stabilization in highly dynamic identified message-passing systems where dynamics is modeled using time-varying graphs (TVGs). More precisely, we address the self-stabilizing leader election problem in three wide classes of TVGs: the class TCB (Δ) of TVGs with temporal diameter bounded by Δ, the class TCB (Δ) of TVGs with temporal diameter quasi-bounded by Δ, and the class TCR of TVGs with recurrent connectivity only, where TCB (Δ) ⊆ TCB (Δ) ⊆ TCR. We first study conditions under which our problem can be solved. Precisely, we introduce the notion of size-ambiguity to show that the assumption on the knowledge of the number n of processes is central. Our results reveal that, despite the existence of unique process identifiers, any deterministic self-stabilizing leader election algorithm working in the TVG class TCB (Δ) or TCR cannot be size-ambiguous, justifying why our solutions for those classes assume the exact knowledge of n. We then present three self-stabilizing leader election algorithms for the TVG classes TCB (Δ), TCB(Δ), and TCR, respectively."
Brief Announcement: Hazard Pointer Protection of Structures with Immutable Links,"The hazard pointer method [4] for safe reclamation is capable of protecting individual dynamic objects, including individual nodes of linked structures. However, on its own, it does not protect the descendants of protected nodes for unconditional traversal."
