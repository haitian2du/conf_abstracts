Secure Distributed Computing Made (Nearly) Optimal,"In this paper, we study secure distributed algorithms that are nearly optimal, with respect to running time, for the given input graph G. Roughly speaking, an algorithm is secure if the nodes learn only their final output while gaining no information on the input (or output) of other nodes."
With Great Speed Come Small Buffers: Space-Bandwidth Tradeoffs for Routing,"We consider the Adversarial Queuing Theory (AQT) model, where packet arrivals are subject to a maximum average rate 0 ≤ ρ ≤ 1 and burstiness σ ≤ 0. In this model, we analyze the size of buffers required to avoid overflows in the basic case of a path. Our main results characterize the space required by the average rate and the number of distinct destinations: we show that O(ℓ d1/ℓ + σ) space suffice, where d is the number of distinct destinations and ℓ=⌋1/ρ⌊ and we show that Ω(1 over ℓ d1/ℓ + σ) space is necessary. For directed trees, we describe an algorithm whose buffer space requirement is at most 1 + d' + σ where d' is the maximum number of destinations on any root-leaf path."
Plain SINR is Enough!,"We develop randomized distributed algorithms for many of the most fundamental communication problems in the wireless SINR model, including (multi-message) broadcast, local broadcast, coloring, MIS, and aggregation. The complexity of the algorithms is optimal up to polylogarithmic preprocessing time. It shows -- contrary to expectation -- that the plain vanilla SINR model is just as powerful and fast (modulo the preprocessing) as various extensions studied, including power control, carrier sense, collision detection, free acknowledgements, and GPS location. A key component of the algorithms is an efficient simulation of CONGEST algorithms on a constant-density SINR backbone."
"Efficient Multiparty Interactive Coding for Insertions, Deletions, and Substitutions","In the field of interactive coding, two or more parties wish to carry out a distributed computation over a communication network that may be noisy. The ultimate goal is to develop efficient coding schemes that can tolerate a high level of noise while increasing the communication by only a constant factor (i.e., constant rate)."
Multiparty Interactive Communication with Private Channels,"A group of n players wants to run a distributed protocol ℘ over a network where communication occurs via private point-to-point channels. Can we efficiently simulate ℘ in the presence of an adversary who knows ℘ and is able to maliciously flip bits on the channels? We show that this is possible, even when L, the number of bits sent in ℘, the average message size α in ℘, and T, the number of bits flipped by the adversary are not known in advance. In particular, we show how to create a robust version of ℘, ℘ such that 1) ℘' fails with probability at most δ, for any δ>0; and 2) ℘' sends O( L (1 + (1/α) łog (n L/δ)) + T) bits. We note that if α is Ω (log (n L/δ), then ℘ sends only O(L+T) bits, and is therefore within a constant factor of optimal. Critically, our result requires that ℘ runs correctly in an asynchronous network and our protocol ℘ must run in a synchronous network."
Coded State Machine -- Scaling State Machine Execution under Byzantine Faults,"We introduce Coded State Machine (CSM), an information-theoretic framework to securely and efficiently execute multiple state machines on Byzantine nodes. The standard method of solving this problem is using State Machine Replication, which achieves high security at the cost of low efficiency. CSM simultaneously achieves the optimal linear scaling in storage, throughput, and security with increasing network size. The storage is scaled via the design of Lagrange coded states and coded input commands that require the same storage size as their origins. The computational efficiency is scaled using a novel delegation algorithm, called INTERMIX, which is an information-theoretically verifiable matrix-vector multiplication algorithm of independent interest."
On Termination of a Flooding Process,"Flooding is a fundamental distributed algorithms technique. Consider the following flooding process, for simplicity, in a synchronous message passing network: A distinguished node begins the flooding process by sending the (same) message to all its neighbours in the first round. In subsequent rounds, every node receiving the message relays a copy of the message further to all those, and only those, nodes it did not receive the message from in the previous round. However, the nodes do not remember if they've taken part in the flooding before and therefore will repeat the process every time they get a message. In other words, they execute an amnesiac flooding process with memory only of the present round. The flooding process terminates in a particular round when no edge in the network carries the message in that, and, hence, subsequent, rounds. We call this process Amnesiac Flooding (AF)."
