Session details: Session 7,No abstract available.
Information-Theoretic Lower Bounds on the Storage Cost of Shared Memory Emulation,"The focus of this paper is to understand storage costs of emulating an atomic shared memory over an asynchronous, distributed message passing system. Previous literature has developed several shared memory emulation algorithms based on replication and erasure coding techniques, and analyzed the storage costs of the proposed algorithms. In this paper, we present the first known information-theoretic lower bounds on the storage costs incurred by shared memory emulation algorithms. Our storage cost lower bounds are universally applicable, that is, we make no assumption on the structure of the algorithm or the method of encoding the data."
On the Complexity of Reader-Writer Locks: Extended Abstract,"A reader-writer lock [7] is a widely-used variant of the mutual exclusion lock abstraction [10]. It is shared by $n$ readers and m writers, whose accesses of the Critical Section (CS) must satisfy the following requirement: reader processes are allowed to be in the CS simultaneously but each writer process requires exclusive access. We study the (worst-case) remote memory reference (RMR) complexity of reader-writer locks in the cache-coherent (CC) read/write model [2]."
An Algorithm for Replicated Objects with Efficient Reads,"The problem. We consider the problem of implementing a consistent replicated object in a partially synchronous message passing distributed system susceptible to process and communication failures. The object is a generic shared resource, such as a data structure, a file, or a lock. The processes implementing the replicated object access it by applying operations to it at unpredictable times and potentially concurrently.1 The object should be linearizable: it should behave as if each operation applied to it takes effect at a distinct instant in time during the interval between its invocation and its response."
Are Shared Objects Composable under an Oblivious Adversary?,"Linearizability [5] of a concurrent object ensures that operations on that object appear to execute atomically. It is well known that linearizable implementations are composable: in an algorithm designed to work with atomic objects, replacing any atomic object with a linearizable implementation preserves the correctness of the original algorithm. However, replacing atomic objects with linearizable ones in a randomized algorithm can break the original probabilistic guarantees [3]. With an adaptive adversary, this problem is solved by using strongly linearizable [3] objects in the composition. How about with an oblivious adversary."
Brief Announcement: A Family of Leaderless Generalized-Consensus Algorithms,"Leaderless consensus algorithms in the vein of EPaxos have performance advantages, especially for geo-replication, but are also very intricate, making them hard to modify and adapt for specific use cases. In this paper we show that their core principle can be captured in a generic leaderless generalized-consensus algorithm that uses two new abstractions: a dependency-set algorithm, which suggests dependencies for commands, and a map-agreement algorithm, which ensures that, for each submitted command, processes agree on a dependency set. Our generic algorithm gives rise to a family of algorithms whose members are obtained by using concrete dependency-set and map-agreement algorithms. On top of enabling modular correctness proofs of leaderless consensus algorithms, we expect that the modular structure of our generic leaderless algorithm will allow a principled theoretical and empirical evaluation of the trade-offs that can be achieved by different implementations of our two abstractions."
Brief Announcement: Computing in the Presence of Weak Crash Failures,"We consider an asynchronous shared memory system of n processes where processes may experience weak crash failures. A crash m-failure is a crash failure of a process that may occurs only while the point contention is at most m. It is known that there is no consensus algorithm for n processes using registers that can tolerate even a single crash n-failure. Is there a consensus algorithm for n processes using registers that can tolerate a single crash (n-1)-failure? It is known that there is no k-set consensus algorithm for n>k processes using registers that can tolerate k crash n-failures. How may crash (n-\ell)-failures can a k-set consensus algorithm using registers tolerate, as a function of n, k and l. Answers to these questions follow from our results regarding the ability to tolerate weak crash failures."
Brief Announcement: Oh-RAM! One and a Half Round Read/Write Atomic Memory,"Emulating atomic read/write shared objects in a message-passing system is a fundamental problem in distributed computing. Considering that network communication is the most expensive resource, efficiency is measured first of all in terms of the communication needed to implement read and write operations. It is well known that two communication round-trip phases involving in total four message exchanges are sufficient to implemented atomic operations. In this work we present a comprehensive treatment of the question of when and how it is possible to implement atomic memory where read and write operations complete in three message exchanges, i.e., we aim for One and half Round Atomic Memory, hence the name Oh-RAM! We present algorithms that allow operations to complete in three communication exchanges without imposing any constraints on the number of readers and writers. We present an implementation for the {single-writer/multiple-reader} (SWMR) setting, where reads complete in three communication exchanges and writes complete in two exchanges. Then we pose the question of whether it is possible to implement multiple-writer/multiple-reader (MWMR) memory where operations complete in at most three communication exchanges. In light of our impossibility result these algorithms are optimal in terms of the number of communication exchanges."
Brief Announcement: Space-Time Tradeoffs for Distributed Verification,"Verifying that a network configuration satisfies a given boolean predicate is a fundamental problem in distributed computing. Many variations of this problem have been studied, for example, in the context of proof labeling schemes (PLS), locally checkable proofs (LCP), and non-deterministic local decision (NLD). In all of these contexts, verification time is assumed to be constant. Korman, Kutten and Masuzawa presented a proof-labeling scheme for MST, with poly-logarithmic verification time, and logarithmic memory at each vertex. In this paper we introduce the notion of a t-PLS, which allows the verification procedure to run for super-constant time. Our work analyzes the tradeoffs of t-PLS between time, label size, message length, and computation space. We construct a universal t-PLS and prove that it uses the same amount of total communication as a known one-round universal PLS, and t factor smaller labels. In addition, we provide a general technique to prove lower bounds for space- time tradeoffs of t-PLS. We use this technique to show an optimal tradeoff for testing that a network is acyclic (cycle free). Our optimal t-PLS for acyclicity uses label size and computation space O((log n)/t). We further describe a recursive O(log* n) space verifier for acyclicity which does not assume previous knowledge of the run-time t."
