"Session details: Session 2C: Security, Blockchains, and Replication",No abstract available.
Atomic Cross-Chain Swaps,"An atomic cross-chain swap is a distributed coordination task where multiple parties exchange assets across multiple blockchains, for example, trading bitcoin for ether."
Interactive Distributed Proofs,"Interactive proof systems allow a resource-bounded verifier to decide an intractable language (or compute a hard function) by communicating with a powerful but untrusted prover. Such systems guarantee that the prover can only convince the verifier of true statements. In the context of centralized computation, a celebrated result shows that interactive proofs are extremely powerful, allowing polynomial-time verifiers to decide any language in PSPACE. In this work we initiate the study of interactive distributed proofs : a network of nodes interacts with a single untrusted prover, who sees the entire network graph, to decide whether the graph satisfies some property. We focus on the communication cost of the protocol --- the number of bits the nodes must exchange with the prover and each other. Our model can also be viewed as a generalization of the various models of ""distributed NP'' (proof labeling schemes, etc.) which received significant attention recently: while these models only allow the prover to present each network node with a string of advice, our model allows for back-and-forth interaction. We prove both upper and lower bounds for the new model. We show that for some problems, interaction can exponentially decrease the communication cost compared to a non-interactive prover, but on the other hand, some problems retain non-trivial cost even with interaction."
Brief Announcement: Asynchronous Secure Distributed Computing with Transferrable Non-equivocation Revisited,"In this paper, we consider two fundamental problems in secure distributed computing, namely Asynchronous Byzantine Agreement (ABA) and Asynchronous Secure Multi-party Computation (ASMPC). Our focus is on the honest majority setting, involving a set of n mutually distrusting parties, t of which can be under the control of a computationally bounded Byzantine adversary Adv, where t < n/2. It is well known that in the cryptographic setting where the parties have access to a public-key infrastructure (PKI) set-up and are connected by pair-wise channels, both ABA and ASMPC requires t n/3. However, Clement et al. (PODC 2012) and Backes et al. (PODC 2014) showed that it is possible to design computationally-secure ABA and ASMPC protocols respectively, even with t < n/2, provided the parties are available with a transferrable non-equivocation mechanism. Non-equivocation is a message authentication mechanism, which prevents a corrupt sender from sending conflicting messages to different parties. The transferability of the mechanism enables a receiver to verifiably transfer any authenticated statement to other parties, on behalf of the sender. In this paper, we revisit the work of Clement et al. and Backes et al. and show the following: 1. If n Å‚eq 3t, then it is impossible to achieve the traditional notion of validity by any ABA protocol, which demands that if the inputs of all honest parties are same, say x, then all honest parties should output x at the end of the protocol. Moreover, this holds even if the parties are equipped with a transferrable non-equivocation mechanism. 2. The input phase of the ASMPC protocol of Backes et al (and hence the overall ASMPC protocol) may never terminate for the honest parties. The input phase runs an asynchronous primitive called Agreement on a Common Subset (ACS), which allows the honest parties to agree upon a common subset of n - t parties who provide their inputs for the computation. The ACS primitive runs n parallel instances of an ABA protocol, where the ith instance is to decide whether the ith party has provided its input. We show that since the underlying ABA instances does not satisfy the validity condition, the ACS primitive may never terminate for the honest parties; this results in the honest parties waiting indefinitely to identify the set of n - t input providers."
Brief Announcement: Sustainable Blockchains through Proof of eXercise,"Cryptocurrency and blockchain technologies are recently gaining wide adoption since the introduction of Bitcoin, being distributed, authority-free, and secure. Proof of Work (PoW) is at the heart of blockchain's security, asset generation, and maintenance. Although simple and secure, a hash-based PoW like Bitcoin's puzzle is often referred to as ""useless'', and the used intensive computations are considered ""waste'' of energy. A myriad of Proof of ""something'' alternatives have been proposed to mitigate energy consumption; however, they either introduced new security threats and limitations, or the ""work'' remained far from being really ""useful''. In this work, we introduce Proof of eXercise (PoX): a sustainable alternative to PoW where an eXercise is a real world matrix-based scientific computation problem. We provide a novel study of the properties of Bitcoin's PoW, the challenges of a more ""rational'' solution as PoX, and we suggest a comprehensive approach for PoX."
Brief Announcement: Partially Replicated Causally Consistent Shared Memory,"Distributed shared memory systems maintain multiple replicas of the shared memory registers. Maintaining causal consistency in such systems has received significant attention in the past. However, much of the previous literature focuses on \em full replication wherein each replica stores a copy of all the registers in the shared memory. In this paper, we investigate causal consistency in partially replicated systems, wherein each replica may store only a subset of the shared data. To achieve causal consistency, it is necessary to ensure that, before an update is performed at any given replica, all causally preceding updates must also be performed. Achieving this goal requires some mechanism to track causal dependencies. In the context of full replication, this goal is often achieved using vector timestamps, with the number of vector elements being equal to the number of replicas. Building on the past work, this paper makes two key contributions: For a family of algorithms for maintaining causal consistency, we present necessary conditions on the metadata (which we refer as a \em timestamp ) that must be maintained by each replica. We present an algorithm for achieving causal consistency using a timestamp that matches one of the necessary conditions referred above, thus showing that the condition is necessary and sufficient both."
Brief Announcement: Optimal Record and Replay under Causal Consistency,"We investigate the minimum record needed to replay executions of processes that share causally consistent memory. For a version of causal consistency, we identify optimal records under both offline and online recording setting. Under the offline setting, a central authority has information about every process' view of the execution and can decide what information to record for each process. Under the online setting, each process has to decide on the record at runtime as the operations are observed."
Brief Announcement: MUSIC: Multi-Site Entry Consistencyfor Geo-Distributed Services,"Geo-distributed services that are executed across multiple sites at a global scale are increasingly prevalent, and are at the core of the control plane tasked with managing the Virtual Network Functions (VNFs) of next-generation network infrastructure. A key building block of any replicated service of this type is logically shared state, an abstraction that is often implemented by having multiple copies of each data element and using one of any number of distributed protocols to enforce consistency with guarantees ranging from eventual to causal to sequential consistency. These solutions fail to meet the real needs of geo-distributed services found in a VNF control plane (and elsewhere), which are to provide guarantees strong enough to be useful, yet still efficiently implementable in a global network with larger latencies and a wider range of failure modes. Here, we propose a new solution to state consistency based on extending entry consistency, a paradigm originally developed for failure-free multi-processor systems, for use in geo-distributed services with failures. We outline the challenges associated with state consistency in such services, and describe a data-store called MUSIC (MUlti-SIte entry Consistency) that combines an eventually consistent key-value store with locking primitives to implement entry-consistent semantics."
