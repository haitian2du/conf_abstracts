Session details: Session 7,No abstract available.
FruitChains: A Fair Blockchain,"Nakamoto's famous blockchain protocol enables achieving consensus in a so-called permissionless setting---anyone can join (or leave) the protocol execution, and the protocol instructions do not depend on the identities of the players. His ingenious protocol prevents ""sybil attacks"" (where an adversary spawns any number of new players) by relying on computational puzzles (a.k.a. ""moderately hard functions"") introduced by Dwork and Naor (Crypto'92). Recent work by Garay et al (EuroCrypt'15) and Pass et al (manuscript, 2016) demonstrate that this protocol provably achieves consistency and liveness assuming a) honest players control a majority of the computational power in the network, b) the puzzle-hardness is appropriately set as a function of the maximum network delay and the total computational power of the network, and c) the computational puzzle is modeled as a random oracle. Assuming honest participation, however, is a strong assumption, especially in a setting where honest players are expected to perform a lot of work (to solve the computational puzzles). In Nakamoto's Bitcoin application of the blockchain protocol, players are incentivized to solve these puzzles by receiving rewards for every ""block"" (of transactions) they contribute to the blockchain. An elegant work by Eyal and Sirer (FinancialCrypt'14), strengthening and formalizing an earlier attack discussed on the Bitcoin forum, demonstrates that a coalition controlling even a minority fraction of the computational power in the network can gain (close to) 2 times its ""fair share"" of the rewards (and transaction fees) by deviating from the protocol instructions. In contrast, in a fair protocol, one would expect that players controlling a φ fraction of the computational resources to reap a φ fraction of the rewards."
Coordination Without Prior Agreement,"Assuming that there is an a priori agreement between processes on the names of shared memory locations, as done in almost all the publications on shared memory algorithms, is tantamount to assuming that agreement has already been solved at the lower-level. From a theoretical point of view, it is intriguing to figure out how coordination can be achieved without relying on such lower-level agreement. In order to better understand the new model, we have designed new algorithms without relying on such a priori lower-level agreement, and proved space lower bounds and impossibility results for several important problems, such as mutual exclusion, consensus, election and renaming. Using these results, we identify fundamental differences between the standard model where there is a lower-level agreement about the shared register's names and the strictly weaker model where there is no such agreement."
Ignore or Comply?: On Breaking Symmetry in Consensus,"We study consensus processes on the complete graph of n nodes. Initially, each node supports one up to n different opinions. Nodes randomly and in parallel sample the opinions of constantly many nodes. Based on these samples, they use an update rule to change their own opinion. The goal is to reach consensus, a configuration where all nodes support the same opinion."
Life Beyond Set Agreement,"The set agreement power of a shared object O describes O's ability to solve set agreement problems: it is the sequence (n_1, n_2, ..., n_k, ...) such that, for every k >= 1, using O and registers one can solve the k-set agreement problem among at most n_k processes. It has been shown that the ability of an object O to implement other objects is not fully characterized by its consensus number the first component of its set agreement power) [1, 3, 14]. This raises the following natural question: is the ability of an object O to implement other objects fully characterized by its set agreement power? We prove that the answer is no: every level n >= 2 of Herlihy's consensus hierarchy has two objects that have the same set agreement power but are not equivalent, i.e., at least one cannot implement the other. We also show that every level n >= 2 of the consensus hierarchy contains a deterministic object O_n with some set agreement power (n_1, n_2, ..., n_k, ...) such that being able to solve the k-set agreement problems among n_k processes, for all k >= 1, is not enough to implement O_n."
Brief Announcement: Hierarchical Consensus,"We introduce Hierarchical Consensus, an approach to generalizing consensus that allows us to scale groups beyond a handful of nodes, across wide areas. Hierarchical Consensus increases the availability of consensus groups by partitioning the decision space and nominating distinct leaders for each partition. Partitions eliminate distance by allowing decision-making to be co-located with replicas that are responding to accesses. A root quorum guarantees global consistency and fault tolerance. Hierarchical consensus is flexible locally, but improves upon prior approaches by balancing load, allowing fast replication across wide areas, and enabling consensus across large (> 100) systems of devices."
Brief Announcement: Statement Voting and Liquid Democracy,"The existing (election) voting systems, e.g., representative democracy, have many limitations and often fail to serve the best interest of the people in collective decision making. To address this issue, the concept of liquid democracy has been emerging as an alternative decision-making model to make better use of ""the wisdom of crowds"". Very recently, a few liquid democracy implementations, e.g. Google Votes and Decentralized Autonomous Organization (DAO), are released; however, those systems only focus on the functionality aspect, as no privacy/anonymity is considered. In this work, we, for the first time, provide a rigorous study of liquid democracy under the Universal Composability (UC) frame- work. In the literature, liquid democracy was achieved via two separate stages -- delegation and voting. We propose an efficient liquid democracy e-voting scheme that uni es these two stages. At the core of our design is a new voting concept called statement voting, which can be viewed as a natural extension of the conventional voting approaches. We remark that our statement voting can be extended to enable more complex voting and generic ledger-based non-interactive multi-party computation. We believe that the statement voting concept opens a door for constructing a new class of e-voting schemes."
Brief Announcement: Rapid Asynchronous Plurality Consensus,"We consider distributed plurality consensus on a complete graph of size n with k initial opinions in the following asynchronous communication model. Each node is equipped with a random Poisson clock with parameter lambda=1. Whenever a node's clock ticks, it samples some neighbors uniformly at random and adjusts its opinion according to the sample."
Brief Announcement: Object Oriented Consensus,"We suggest a template that reveals the structure of many consensus algorithms as a generic procedure. The template builds on a new object, vacillate-adopt-commit which is an extension of the well known adopt-commit object. In addition we extend Aspnes's conciliator object to a new object that we call a reconciliator. The consensus algorithm template works in rounds of alternating vacillate-adopt-commit and reconciliator operations. The vacillate-adopt-commit object observes the processors' preferences and suggests a preference output with a measure of confidence vacillate, adopt or commit) on the preference. The reconciliator ensures termination, by providing new preferences for the processors. We show how several key consensus algorithms exactly fit our template. Here we demonstrate the decomposition of Ben-Or's randomized algorithm. The decomposition of the Phase King Byzantine and the Paxos algorithm are given in the full paper [1]. We analyze and compare our template based on vacillate-adopt-commit and reconciliator objects to previous work [3,5], suggesting a decomposition of consensus based on adopt-commit and conciliator objects. We claim that the three return values of vacillate-adopt-commit more accurately describe existing algorithms."
